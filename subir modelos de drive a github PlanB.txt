// ============================================================
//   SUBIR MODELOS DE GOOGLE DRIVE A GITHUB AUTOM√ÅTICAMENTE
// ============================================================

// üîë CONFIGURACI√ìN GITHUB
const GITHUB_CONFIG = {
  // Obt√©n tu token en: https://github.com/settings/tokens
  // Permisos necesarios: repo (todos)
  GITHUB_TOKEN: '',
  
  // Tu usuario y repositorio
  GITHUB_USER: 'jsgaston82',
  GITHUB_REPO: 'IG-Trading',
  
  // Rama donde subir (main o master)
  BRANCH: 'main',
  
  // Email para commits
  COMMIT_EMAIL: 'jsgaston82@gmail.com',
  COMMIT_NAME: 'Colab Bot'

};

const TELEGRAM_CONFIG = {
  BOT_TOKEN: '8502620685:AAGnHy3x5iC5ACP91hYEnJ-yrl4_7oUUAdk',
  CHAT_ID: '5825443798'
};


const DRIVE_FOLDERS = {
  MODELS: '1iNG2CE1-zdorfiOhi2hjWtkxf65hZi9p', // FOREX_MODELS
  ROOT: 'root' // Mi unidad (main)
};

// üìÅ ARCHIVOS A SUBIR DESDE DRIVE
const ARCHIVOS_DRIVE = [
  {
    nombre: 'eurusd_lstm_daily.onnx',
    rutaGithub: 'models/pytorch/eurusd_lstm_daily.onnx',
    descripcion: 'Modelo PyTorch ONNX',
    origen: 'MODELS'
  },
  {
    nombre: 'eurusd_lstm_daily.pth',
    rutaGithub: 'models/tensorflow/eurusd_lstm_daily.pth',
    descripcion: 'Modelo TensorFlow',
    origen: 'MODELS'
  },
  {
    nombre: 'eurusd_scaler_daily.pkl',
    rutaGithub: 'models/scalers/eurusd_scaler_daily.pkl',
    descripcion: 'Scaler',
    origen: 'MODELS'
  },
  {
    nombre: 'eurusd_model_config_daily.json',
    rutaGithub: 'models/config/eurusd_model_config_daily.json',
    descripcion: 'Config modelo',
    origen: 'MODELS'
  },
  {
    nombre: 'training_results.png',
    rutaGithub: 'results/training_results.png',
    descripcion: 'Resultados entrenamiento',
    origen: 'ROOT'
  },
  {
    nombre: 'EURUSD_1d_data.csv',
    rutaGithub: 'data/EURUSD_1d_data.csv',
    descripcion: 'Dataset diario',
    origen: 'ROOT'
  }
];



function enviarTelegram(mensaje) {
  const url = `https://api.telegram.org/bot${TELEGRAM_CONFIG.BOT_TOKEN}/sendMessage`;
  
  const payload = {
    chat_id: TELEGRAM_CONFIG.CHAT_ID,
    text: mensaje,
    parse_mode: 'Markdown'
  };

  UrlFetchApp.fetch(url, {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  });
}


// ============================================================
//   FUNCI√ìN PRINCIPAL - SUBIR A GITHUB
// ============================================================

function subirModelosAGitHub() {
  Logger.log('üì¶ Iniciando subida a GitHub...');

  // ‚è∏Ô∏è Filtro horario Forex
  if (!estaEnHorarioForex()) {
    Logger.log('‚è∏ Fuera de horario Forex. No se ejecuta.');
    return;
  }

  const fecha = new Date().toLocaleString('es-ES', { timeZone: 'Europe/Madrid' });
  const timestamp = new Date().toISOString().split('T')[0];

  // ‚ö†Ô∏è DECLARAR FUERA DEL TRY
  let archivosSubidos = 0;
  let errores = [];

  try {
    // üìÅ Carpetas Drive
    const carpetas = {
      MODELS: DriveApp.getFolderById(DRIVE_FOLDERS.MODELS),
      ROOT: DriveApp.getRootFolder()
    };

    // üîÅ Procesar archivos
    for (const archivoConfig of ARCHIVOS_DRIVE) {
      try {
        Logger.log(`üì§ Subiendo: ${archivoConfig.nombre}`);

        const carpetaOrigen = carpetas[archivoConfig.origen];
        if (!carpetaOrigen) {
          throw new Error(`Carpeta origen no definida: ${archivoConfig.origen}`);
        }

        const archivos = carpetaOrigen.getFilesByName(archivoConfig.nombre);
        if (!archivos.hasNext()) {
          errores.push(`${archivoConfig.nombre}: No encontrado`);
          Logger.log(`‚ö†Ô∏è No encontrado en Drive`);
          continue;
        }

        const archivo = archivos.next();
        const contenido = Utilities.base64Encode(archivo.getBlob().getBytes());

        const resultado = subirArchivoAGitHub(
          archivoConfig.rutaGithub,
          contenido,
          `ü§ñ Auto-update: ${archivoConfig.descripcion} (${timestamp})`,
          archivoConfig.nombre
        );

        if (resultado.success) {
          archivosSubidos++;
          Logger.log('‚úÖ Subido correctamente');
        } else {
          errores.push(`${archivoConfig.nombre}: ${resultado.error}`);
          Logger.log(`‚ùå Error GitHub: ${resultado.error}`);
        }

        Utilities.sleep(800);

      } catch (e) {
        errores.push(`${archivoConfig.nombre}: ${e.message}`);
        Logger.log(`‚ùå Error archivo: ${e.message}`);
      }
    }

    crearReadmeAutomatico(timestamp);
    enviarNotificacionGitHub(archivosSubidos, errores, fecha);

  } catch (error) {
    Logger.log(`‚ùå Error general: ${error.message}`);
    enviarNotificacionErrorGitHub(error, archivosSubidos);
  }
}


// ============================================================
//   SUBIR ARCHIVO A GITHUB (API REST)
// ============================================================

function subirArchivoAGitHub(ruta, contenidoBase64, mensajeCommit, nombreArchivo) {
  try {
    const url = `https://api.github.com/repos/${GITHUB_CONFIG.GITHUB_USER}/${GITHUB_CONFIG.GITHUB_REPO}/contents/${ruta}`;
    
    // Primero, verificar si el archivo existe (para obtener SHA)
    let sha = null;
    try {
      const checkOptions = {
        method: 'get',
        headers: {
          'Authorization': `token ${GITHUB_CONFIG.GITHUB_TOKEN}`,
          'Accept': 'application/vnd.github.v3+json'
        },
        muteHttpExceptions: true
      };
      
      const checkResponse = UrlFetchApp.fetch(url, checkOptions);
      if (checkResponse.getResponseCode() === 200) {
        const existingFile = JSON.parse(checkResponse.getContentText());
        sha = existingFile.sha;
        Logger.log(`  üìù Actualizando archivo existente (SHA: ${sha.substring(0, 7)}...)`);
      }
    } catch (e) {
      Logger.log(`  ‚ú® Creando nuevo archivo`);
    }
    
    // Preparar payload
    const payload = {
      message: mensajeCommit,
      content: contenidoBase64,
      branch: GITHUB_CONFIG.BRANCH,
      committer: {
        name: GITHUB_CONFIG.COMMIT_NAME,
        email: GITHUB_CONFIG.COMMIT_EMAIL
      }
    };
    
    // Si existe, a√±adir SHA para actualizar
    if (sha) {
      payload.sha = sha;
    }
    
    // Subir archivo
    const options = {
      method: 'put',
      contentType: 'application/json',
      headers: {
        'Authorization': `token ${GITHUB_CONFIG.GITHUB_TOKEN}`,
        'Accept': 'application/vnd.github.v3+json'
      },
      payload: JSON.stringify(payload),
      muteHttpExceptions: true
    };
    
    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();
    
    if (responseCode === 200 || responseCode === 201) {
      const result = JSON.parse(response.getContentText());
      return {
        success: true,
        sha: result.content.sha,
        url: result.content.html_url
      };
    } else {
      const errorMsg = response.getContentText();
      return {
        success: false,
        error: `HTTP ${responseCode}: ${errorMsg.substring(0, 100)}`
      };
    }
    
  } catch (error) {
    return {
      success: false,
      error: error.toString()
    };
  }
}

// ============================================================
//   CREAR README AUTOM√ÅTICO
// ============================================================

function crearReadmeAutomatico(timestamp) {
  Logger.log('\nüìù Creando README...');
  
  const readme = `# ü§ñ Forex LSTM Models - Auto-updated

![Last Update](https://img.shields.io/badge/Last%20Update-${timestamp}-blue)
![Status](https://img.shields.io/badge/Status-Active-green)

## üìä Modelo EUR/USD LSTM

Modelos LSTM para predicci√≥n de precios EUR/USD, entrenados con datos hist√≥ricos de 1 hora.

### üìÅ Estructura del Repositorio

\`\`\`
forex-models/
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ pytorch/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ eurusd_lstm_pytorch.onnx      # Modelo PyTorch (formato ONNX)
‚îÇ   ‚îú‚îÄ‚îÄ tensorflow/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ eurusd_lstm_tf2onnx.onnx      # Modelo TensorFlow (formato ONNX)
‚îÇ   ‚îú‚îÄ‚îÄ scalers/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ eurusd_scaler_improved.pkl    # Scaler MinMaxScaler
‚îÇ   ‚îî‚îÄ‚îÄ config/
‚îÇ       ‚îî‚îÄ‚îÄ eurusd_model_config_improved.json  # Configuraci√≥n del modelo
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îî‚îÄ‚îÄ EURUSD_1h_data.csv                # Dataset actualizado (10k+ registros)
‚îî‚îÄ‚îÄ results/
    ‚îî‚îÄ‚îÄ training_results.png              # Gr√°ficas de entrenamiento
\`\`\`

### üîÑ Actualizaci√≥n Autom√°tica

Este repositorio se actualiza autom√°ticamente:
- **Frecuencia:** Domingo a Jueves, 21:00 CET
- **M√©todo:** Google Apps Script + Colab
- **√öltima actualizaci√≥n:** ${timestamp}

### üìà Caracter√≠sticas del Modelo

- **Arquitectura:** LSTM mejorado (3 capas, 256 unidades)
- **Features:** Open, High, Low, Close
- **Secuencia:** 60 per√≠odos (60 horas)
- **Datos:** EUR/USD 1h desde ${new Date().getFullYear() - 2}
- **Formato:** ONNX (compatible con m√∫ltiples frameworks)

### üöÄ Uso del Modelo

#### Python con ONNX Runtime

\`\`\`python
import onnxruntime as ort
import numpy as np

# Cargar modelo
session = ort.InferenceSession('models/pytorch/eurusd_lstm_pytorch.onnx')

# Preparar input (60 per√≠odos, 4 features)
input_data = np.random.randn(1, 60, 4).astype(np.float32)

# Predicci√≥n
outputs = session.run(None, {'input': input_data})
prediction = outputs[0]
\`\`\`

### üìä M√©tricas de Entrenamiento

Ver \`results/training_results.png\` para gr√°ficas detalladas.

### üìù Licencia

MIT License - Uso libre para fines educativos y comerciales.

### ü§ù Contribuciones

Este repositorio es auto-generado. Para cambios en el modelo, contacta al mantenedor.

---

**ü§ñ Auto-generado por Colab Automation Script**  
**üìÖ √öltima actualizaci√≥n:** ${new Date().toLocaleString('es-ES', { timeZone: 'Europe/Madrid' })}
`;
  
  const contenidoBase64 = Utilities.base64Encode(readme);
  
  const resultado = subirArchivoAGitHub(
    'README.md',
    contenidoBase64,
    `üìù Auto-update README (${timestamp})`,
    'README.md'
  );
  
  if (resultado.success) {
    Logger.log('  ‚úÖ README creado/actualizado');
  } else {
    Logger.log(`  ‚ö†Ô∏è Error en README: ${resultado.error}`);
  }
}

// ============================================================
//   NOTIFICACIONES
// ============================================================

function enviarNotificacionGitHub(archivosSubidos, errores, fecha) {
  const emoji = errores.length === 0 ? '‚úÖ' : '‚ö†Ô∏è';
  const estado = errores.length === 0 ? '√âXITO' : 'COMPLETADO CON ERRORES';
  
  const asunto = `${emoji} Modelos subidos a GitHub`;
  
  let cuerpoEmail = `
Subida autom√°tica a GitHub

üìä Resultado: ${estado}
‚úÖ Archivos subidos: ${archivosSubidos}/${ARCHIVOS_DRIVE.length}
üìÖ Fecha: ${fecha}

üîó Repositorio: https://github.com/${GITHUB_CONFIG.GITHUB_USER}/${GITHUB_CONFIG.GITHUB_REPO}

üìÅ Archivos:
`;

  ARCHIVOS_DRIVE.forEach(archivo => {
    cuerpoEmail += `- ${archivo.nombre}\n`;
  });
  
  if (errores.length > 0) {
    cuerpoEmail += `\n‚ùå Errores:\n`;
    errores.forEach(error => {
      cuerpoEmail += `- ${error}\n`;
    });
  }
  
  cuerpoEmail += `\n---
Automatizaci√≥n via Google Apps Script
`;
  
  GmailApp.sendEmail('jsgaston82@gmail.com', asunto, cuerpoEmail);
  
  // Telegram si est√° configurado
  if (typeof CONFIG !== 'undefined' && CONFIG.USAR_TELEGRAM) {
    const mensajeTelegram = `${emoji} *GitHub Sync*

üì¶ ${archivosSubidos}/${ARCHIVOS_DRIVE.length} archivos
üìÖ ${fecha}

üîó github.com/${GITHUB_CONFIG.GITHUB_USER}/${GITHUB_CONFIG.GITHUB_REPO}`;
    
    enviarTelegram(mensajeTelegram);
  }
  
  Logger.log('üìß Notificaciones enviadas');

const mensajeTelegram = `
üì¶ *GitHub Sync FOREX_MODELS*

‚úÖ ${archivosSubidos}/${ARCHIVOS_DRIVE.length} archivos
‚ùå Errores: ${errores.length}
üìÖ ${fecha}

üîó https://github.com/${GITHUB_CONFIG.GITHUB_USER}/${GITHUB_CONFIG.GITHUB_REPO}
`;

enviarTelegram(mensajeTelegram);




}

function enviarNotificacionErrorGitHub(error, archivosSubidos = 0) {
  const mensaje = `
‚ùå *Error en GitHub Sync*

üì¶ Archivos subidos: ${archivosSubidos}
üß® Error:
${error.message || error}

üìÖ ${new Date().toLocaleString('es-ES', { timeZone: 'Europe/Madrid' })}
`;

  enviarTelegram(mensaje);
  Logger.log('üì≤ Notificaci√≥n de error enviada a Telegram');
}




function borrarTodosLosTriggers() {
  ScriptApp.getProjectTriggers().forEach(t => ScriptApp.deleteTrigger(t));
  Logger.log('üßπ Todos los triggers eliminados');
}





// ============================================================
//   CONFIGURACI√ìN DE TRIGGER PARA GITHUB
// ============================================================
function instalarTriggerUnico() {
  borrarTodosLosTriggers();

  ScriptApp.newTrigger('subirModelosAGitHub')
    .timeBased()
    .everyMinutes(30)
    .create();

  enviarTelegram('‚è∞ Trigger √∫nico instalado (cada 30 min)');
}

function estaEnHorarioForex() {
  const ahora = new Date();
  const zona = 'Europe/Madrid';
  const hora = Number(Utilities.formatDate(ahora, zona, 'H'));
  const dia = Utilities.formatDate(ahora, zona, 'u'); // 1=lun ... 7=dom

  // Forex: domingo 20:00 ‚Üí viernes 22:00
  if (dia == 7 && hora < 23) return false; // domingo antes de 23
  if (dia == 5 && hora >= 23) return false; // viernes despu√©s de 22
  if (dia == 6) return false; // s√°bado

  // Ventana diaria 20:00 ‚Üí 02:00
  if (hora >= 20 || hora < 5) return true;

  return false;
}


// ============================================================
//   FUNCIONES DE UTILIDAD
// ============================================================

function probarSubidaGitHub() {
  Logger.log('üß™ Probando subida a GitHub...');
  subirModelosAGitHub();
}

function verificarConfigGitHub() {
  Logger.log('='.repeat(60));
  Logger.log('CONFIGURACI√ìN GITHUB');
  Logger.log('='.repeat(60));
  Logger.log('Usuario: ' + GITHUB_CONFIG.GITHUB_USER);
  Logger.log('Repositorio: ' + GITHUB_CONFIG.GITHUB_REPO);
  Logger.log('Rama: ' + GITHUB_CONFIG.BRANCH);
  Logger.log('Token: ' + (GITHUB_CONFIG.GITHUB_TOKEN ? 'Configurado ‚úì' : 'NO configurado ‚úó'));
  Logger.log('Archivos a subir: ' + ARCHIVOS_DRIVE.length);
  Logger.log('='.repeat(60));
  
  // Verificar token
  if (GITHUB_CONFIG.GITHUB_TOKEN && GITHUB_CONFIG.GITHUB_TOKEN !== 'ghp_TU_TOKEN_AQUI') {
    try {
      const url = `https://api.github.com/repos/${GITHUB_CONFIG.GITHUB_USER}/${GITHUB_CONFIG.GITHUB_REPO}`;
      const options = {
        method: 'get',
        headers: {
          'Authorization': `token ${GITHUB_CONFIG.GITHUB_TOKEN}`,
          'Accept': 'application/vnd.github.v3+json'
        },
        muteHttpExceptions: true
      };
      
      const response = UrlFetchApp.fetch(url, options);
      if (response.getResponseCode() === 200) {
        const repo = JSON.parse(response.getContentText());
        Logger.log('‚úÖ Acceso al repositorio: OK');
        Logger.log('   Nombre completo: ' + repo.full_name);
        Logger.log('   Privado: ' + (repo.private ? 'S√≠' : 'No'));
      } else {
        Logger.log('‚ùå Error accediendo al repositorio: ' + response.getResponseCode());
      }
    } catch (error) {
      Logger.log('‚ùå Error: ' + error);
    }
  } else {
    Logger.log('‚ö†Ô∏è Configura el token de GitHub primero');
  }
}